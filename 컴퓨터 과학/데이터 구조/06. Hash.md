# Hash

## Hash 란
+ 데이터를 다루는 기법 중 하나로, 해시 함수(Hash Function) 을 통하여 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 방식이다.
+ 매핑 전 원래 데이터의 값을 Key, 매핑 후 데이터의 값을 Hash Value 혹은 Hash Code라고 하여 Key-Value 매핑되는 과정 자체를 Hashing 이라 한다.

<br>

## Hash Table
+ 해시 테이블은 Key 와 Value가 하나의 쌍을 이루는 데이터 구조이다. 즉, 키와 배열의 인덱스를 이용하여 키를 저장하는 자료구조이다.
+ 해시 테이블은 키를 해시 함수로 계산하여 그 값을 배열의 인덱스로 사용한다.

+ 시간복잡도
    - 저장 단계의 시간 복잡도는 `O(1)` 이나, 최악의 경우 `O(n)` 까지 내려갈 수 있다.
    - 삭제나 검색 또한 최소 `O(1)`, 최악 `O(n)` 까지 내려갈 수 있다.

<br>

![image](https://user-images.githubusercontent.com/49611158/146523729-10419d51-023f-45d3-8a7e-e1420e993c8a.png)

<br>

+ 이런 방식으로 데이터를 저장하다 보면 계산된 인덱스 값이 중복될 수 있다. 이러한 경우를 충돌 (Collision) 이라 한다.

<br>

![image](https://user-images.githubusercontent.com/49611158/146523971-9cac3991-bd96-442b-a224-6f2d4387ef28.png)

<br>

## 해시 함수의 종류
+ 해시 함수에서 중요한 것은 고유한 인덱스 값을 설정하는 것이다.
+ Division Method
    - 나눗셈을 이용하는 방법
    - 입력값을 테이블의 크기로 나누어 계산한다.
    - 테이블의 크기를 소수로 정하고, 2의 제곱수와 먼 값을 사용하는 것이 효율이 좋다고 알려져있다.
+ Digit Folding
    - 각 key의 문자열을 ASCII 코드로 바꾸고, 값을 합한 데이터를 테이블 내의 주소로 사용한다.
+ Multiplication Method
    - 숫자로 된 Key 값 K, 0~1 사이의 실수 A, 2의 제곱수인 m 을 사용하여 다음 계산을 수행한다.
    - `h(k) = (k*A mod 1) * m
+ Univeral Hashing
    - 다수의 해시함수를 만들어 집합 H에 넣어두고, 무작위로 해시함수를 선택해 해시값을 만든다.

<br>



## 충돌의 해결 방법

### Seperating Chaining (채이닝)
+ 연결 리스트 혹은 트리를 사용하는 방식이다.
+ 인덱스가 충돌이 일어날 때, 인덱스가 가리키고 있는 연결 리스트의 노드를 추가하여 값을 삽입한다.
+ 데이터 검색 시에는 키에 대한 인덱스가 가리키고 있는 연결 리스트를 선형 검색하여 키에 대한 데이터를 반환한다.
+ 삭제 시에도 인덱스가 가리키는 연결 리스트에서 노드를 삭제한다.

+ 장점
    - 한정된 저장소를 효율적으로 사용할 수 있다.
    - 해시 함수를 선택에 대한 중요성이 상대적으로 적다.
    - 상대적으로 적은 메모리를 사용한다. 미리 공간을 배정할 필요가 없다.
+ 단점
    - 한 Hash에 자료들이 계속 연결된다면(쏠림 현상) 검색 효율이 낮아질 수 있다.
    - 외부 저장 공간을 사용하여 이에 대한 추가 작업이 필요하다

<br>

![image](https://user-images.githubusercontent.com/49611158/146527490-6e469da5-9dc0-47d3-ba71-d8c5a8aab77b.png)

<br>

+ 시간복잡도
    - 삽입
        + Head 에 저장 시에는 해시 계산 후 값을 연결하기만 하면 되므로 `O(1)`
        + Tail 에 저장 시에는 Head를 지나 모든 연결 리스트를 지나 Tail 로 가야 하므로 `O(a)`, 최악의 경우 `O(n)` 이다.
    - 삭제 및 검색
        + 계산된 해시 값을 차례로 살펴보아야 하므로 `O(a)`, 최악의 경우 `O(n)` 이다.

<br>

### Open Addressing (개방주소법)
+ 충돌 발생 시 비어있는 해시를 찾아 데이터를 저장하는 기법이다.    
때문에 1개의 해시에 1개의 값만 매칭되는 형태로 유지된다.
+ 비어있는 해시를 찾는 과정은 항상 동일해야 한다.
    - 선형 탐색 : 다음 해시(+1) 이나 n개(+n)를 뛰어넘어 비어있는 해시에 데이터를 저장한다.
    - 제곱 탐색 : 충돌이 일어난 해시의 제곱을 한 해시에 데이터를 저장한다.
    - 이중 해시 : 다른 해시 함수를 한번 더 적용한 해시에 데이터를 저장한다.
+ 장점
    - 별도의 저장 공간 없이 해시 테이블 내에서 저장 및 처리가 가능하다.
+ 단점
    - 해시 함수의 성능에 의해 전체 해시 테이블의 성능이 결정된다.
    - 데이터의 길이가 늘어나면 그에 해당하는 저장소를 마련해야한다.
+ 시간 복잡도
    - 삽입, 삭제, 검색 모두 해시를 찾아가는 과정에 따라 시간복잡도가 계산된다.
    - 최상의 경우 `O(1)`, 모든 저장소를 찾아봐야 하는 경우 `O(n)`
    - 따라서 개방주소법에서는 저장소가 어느 정도 채워졌을 때 빈 공간을 추가로 확보해줄 필요성이 있다.

<br>

## 해시의 단점
+ 순서가 있는 배열에는 어울리지 않는다.
    - 상하관계가 있거나, 순서가 중요할 경우 해시 테이블은 순서와 무관하게 key 만을 가지고 해시를 찾아 저장하므로 어울리지 않는다.
+ 공간 효율성이 떨어진다.
    - 데이터가 저장되기 전에 미리 저장공간의 확보가 필요하다.
+ 해시 함수에 대한 의존도가 높다.
    - 평균 데이터 처리 시간복잡도는 `O(1)` 이지만, 이는 해시 함수의 연산을 고려하지 않은 복잡도이다.
    - 해시 함수가 너무 복잡하다면 시간 효율석이 떨어질 수 있다.