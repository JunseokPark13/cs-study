1. 브라우저의 렌더링 과정
    1. 주소창에 url 을 입력한다.
    2. 웹 브라우저는 입력받은 url 을 파싱하여 프로토콜, 도메인, 포트를 분석한다.    
    HTTP는 기본 포트가 80, HTTPS는 기본 포트가 443이다.    
    ![image](https://user-images.githubusercontent.com/49611158/146183458-a0ccb60c-2eff-4baa-b032-e60a92b77041.png)    
    3. HSTS(Http Strict Transport Security) 목록을 조회하여, 해당 URL이 목록에 존재한다면 HTTP 요청이라 해도 HTTPS 로 요청한다.    
        + HSTS : HTTP 를 허용하지 않고 HTTPS만을 허용하는 기능으로, 일정 기간 동안 이용자의 https 접속을 강제할 수 있다.    
        HSTS가 적용된 웹 사이트의 웹 서버는 클라이언트에게 HTTPS만을 사용할 수 있음을 알려주고, 이를 지원하는 브라우저는 이를 해석 후 적용한다.
    4. URL을 IP 주소로 변환한다.
        + 브라우저는 자신의 로컬 hosts 파일과 브라우저 캐시에 해당 URL이 존재하는지 확인
        + 없다면 DNS(Domain Name System) 서버에 요청하여 해당 URL을 IP 주소로 변환
        + `www.daum.net` 주소를 변환한다면    
            1. 미리 설정된 Local DNS에 IP 주소 요청  
            2. 없다면 root DNS 서버에 IP 주소 요청   
            3. 없다면 Local DNS는 `.net` 도메인을 관리하는 DNS 서버에 주소 요청
            4. 없다면 Local DNS는  `daum.net` 도메인을 관리하는 DNS 서버에 주소 요청     
            5. IP 주소를 응답 받는다면 Local DNS는 해당 IP 주소를 캐싱하고 응답함.     
            ![image](https://user-images.githubusercontent.com/49611158/146184030-cf06832a-37d5-40c7-b153-5786a7e8fef4.png)
    5. 라우터를 통해 해당 서버의 게이트웨이까지 이동
        - 라우터의 라우팅 테이블을 통한 라우팅으로 해당 IP 주소까지 이동
    6. ARP 를 통해 IP 주소를 MAC 주소로 변환
        - 논리 주소인 IP를 물리 주소인 MAC 주소로 변환해야 한다.    
        이를 위해 해당 네트워크 내에서 ARP(Address Resolution Protocol)를 브로드 캐스팅한다. 해당 IP 주소를 가진 노드는 자신의 MAC 주소를 응답한다.
        - ARP(Address Resolution Protocol) : 주소 결정 프로토콜로, 네트워크 상에서 논리적 IP 주소를 물리적 MAC 주소로 대응시키기 위해 사용되는 프로토콜
    7. 대상 서버와 TCP 소켓 연결
        + 3-way-hand-shake 방식을 통해 TCP 소켓 연결을 진행한다.
        + ![image](https://user-images.githubusercontent.com/49611158/146184260-22f51aaf-661c-48fb-aa7b-6663581deed7.png)
    8. HTTP(HTTPS) 프로토콜로 요청 및 응답
        + 연결이 확정된 후, 해당 페이지를 달라고 서버에 요청한다.
        + 서버에서는 해당 요청을 받은 뒤, 이 요청을 수락할 수 있는지 검사한다.
        + 이 후, 서버는 요청에 대한 응답을 생성하여 브라우저에게 전달한다.
    9. 브라우저에서 응답을 해석
        + 서버로부터 받은 데이터는 HTML, CSS, Javascript 코드들로 이루어져있다. 이제 브라우저는 이를 랜더링하기 위해 해당 코드들을 분석한다.
        1. HTML 코드로 DOM 트리 생성
            + 변환 : 브라우저가 HTML의 원시 바이트를 읽어 HTML에 정의된 인코딩에 따라 개별 문자로 변환
            + 토큰화 : 브라우저가 문자열을 W3C 표준에 지정된 고유 토큰으로 변환
            + 렉싱 : 토큰은 해당 속성 및 규칙을 정의하는 객체로 변환됨
            + DOM 생성 : HTML 마크업에 정의된 여러 태그 간의 관계 해석을 통해 트리 구조로 연결됨
        2. CSSOM 트리 생성
            + HTML 마크업 내에 직접 (inline) 선언된 스타일도 있지만, 외부 css 파일을 참조하거나 head 태그에 style 태그를 정의할 수도 있기 때문에 이를 브라우저가 이해하고 처리할 수 있는 형식으로 변환해야 한다.
            + DOM 트리를 생성하는 것 처럼 변환, 토큰화, 렉싱 과정을 거쳐 CSSOM 트리를 생성한다.
        3. 렌더링 트리 생성
            + DOM 트리와 CSSOM 트리가 생성되면 이 둘을 결합하여 렌더링 트리를 생성한다. 이에는 페이지를 렌더링 하는데 필요한 노드만 포함된다.
        4. 레이아웃 단계
            + 뷰포트 내에서 각 요소의 정확한 위치와 크기를 캡처하는 Box 모델로 출력된다. 모든 상대적인 측정값은 화면에서 절대적인 픽셀로 변환된다.
            + 즉, 브라우저 화면의 어떤 위치에 어떤 크기로 출력될지 계산하는 단계이다.
        5. 페인팅 단계
            + 렌더링 트리의 각 노드를 화면의 실제 픽셀로 변환하게 된다.
            + 레이아웃 단계에서 모든 계산이 완료되면, 화면에 요소들을 그리게 된다.
        6. Javscript 코드의 경우
            + 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다.
            + HTML 파서가 script를 만나면, 자바스크립트 코드 실행을 위해 DOM 생성 프로세스를 중단하고 자바스크립트 엔진에 제어 권한을 넘긴다.
            + 자바스크립트 엔진은 script 태그 내의 js 코드와 src 속성에 정의된 js 파일을 로드하고 파싱하여 실행한다.
            + 자바스크립트 실행이 끝나면 다시 html 파서로 제어 권한을 넘기고 다시 DOM 생성을 재개한다.
            + 브라우저는 동기적으로 HTML, CSS, Javascript를 처리하므로 보통 body 요소의 가장 아래에 script 태그를 위치시키는 것이 좋다.

2. Http 와 Https 통신 방식의 차이
    + HTTP(Hyper Text Transfer Protocol)는 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜로, Application 레벨의 프로토콜로 TCP/IP 위에서 작동한다.
    + 하지만 HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 것이기 때문에 제 3자가 정보를 조회할 위험이 있다.
    + HTTPS (Hypertext Transfer Protocol Over Secure Socket Layer)는 HTTP에 Secure 의 개념인 데이터 암호화가 추가된 프로토콜이다.      
    HTTP 는 80번 포트를 사용하는 것과 다르게 443번 포트를 사용하며, 공개키 암호화 방식을 지원하고 있다.
    + SSL(Secure Socket Layer) : 컴퓨터 네트워크에 통신 보안을 제공하기 위해 설계된 암호 규약. TLS 은 SSL 의 업그레이드 버전이지만, 지금은 SSL 이라는 명칭으로 묶어 부른다.
    + Https의 동작 과정
        1. A 기업은 Http 기반의 애플리케이션에 https를 적용하기 위해 공개키/개인키를 발급함
        2. CA 기업(인증기관)에게 돈을 지불하고, 공개키를 저장하는 인증서의 발급을 요청함
        3. CA 기업은 CA기업의 이름, 서버의 공개키, 서버의 정보 등으로 인증서를 생성하고, CA 기업의 개인키로 암호화하여 A기업에 제공함
        4. A기업은 클라이언트에게 암호화된 인증서를 제공함
        5. 브라우저는 CA 기업의 공개키를 미리 다운받아 갖고 있고, 암호화된 인증서를 복호화함
        6. 암호화된 인증서를 복호화하여 얻은 A기업의 공개키로 데이터를 암호화하여 요청을 전송함
3. OOP의 특징
    + OOP는 Object Oriented Programming의 약자로, 객체지향 프로그래밍이라 한다.
    1. 상속 : 상위 클래스(부모)로 부터 하위 클래스(자식)이 유산을 물려받는 것 처럼 부모의 메소드나 변수를 사용할 수 있음
    2. 다형성 : 같은 객체임에도 상황에 따라 다르게 동작할 수 있음 (오버로딩, 오버라이딩)
    3. 캡슐화 : 변수와 메서드를 하나로 묶고, 필요에 따라 접근 권한을 나누어 외부에서 함부러 접근하지 못하게 막음
    4. 추상화 : 객체들이 사용하는 공통적인 변수나 메서드들을 따로 묶어서 정의할 수 있음
4. 함수형 프로그래밍
    + OOP와는 다른, 함수를 기반으로 하는 프로그래밍 방식
    + 함수형 프로그래밍의 원칙
        1. 입출력이 순수해야 함 (순수 함수)
        2. 부작용(부산물)이 없어야 함 (바꾸자는 변수 외에는 변경이 없어야 하고, 원본 데이터는 불변해야 함)
        3. 함수와 데이터를 중점으로 생각해야 함
    + 순수함수의 특징
        - 작성한 함수가 하나 이상의 인자를 받아야 한다.
        - 반환 값이 반드시 존재해야 한다.
        - 함수 내의 인자를 제외한 다른 변수는 사용하면 안된다.
        - 동일 입력, 동일 출력이 보장된다.
    + 자바스크립트에서는 이를 위한 map, filter, reduce 와 같은 고차함수를 활용하는 것이 좋다.
    + 객체지향은 객체 안에 상태를 저장하고, 이를 조정하기 위해 다양한 기능을 사용하지만 함수형은 상태를 저장하지 않고 없애는 것에 집중한다.
5. 웹 프로토콜
    + 웹 프로토콜이란 : 웹에서 사용되는 통신규약. 나와 상대방의 동작을 약속하는 것
    + `protocol://computer_name:port/document_name?parameters`
        - protocol : 문서에 접근하기 위해 사용하는 프로토콜 이름
        - computer_name : 문서가 있는 컴퓨터(서버)의 도메인 이름
        - port : 서버가 어떤 포트 숫자를 바라보고 있는지
        - document_name : 서버 컴퓨터에 있는 특정 문서의 이름
        - parameters : 페이지에 넘기는 변수
    + HTTP 통신
        - 웹 프로토콜 중 하나로, 가장 많이 쓰이는 Hyper Text Transfer Protocol의 약자이다. 요청과 응답으로 이루어져있다.
        - HTTP 4가지 요청 형식
            - GET : 문서를 요청. 서버가 상태 정보와 복제된 문서를 보냄 (조회)
            - HEAD : 상태 정보를 요청. GET과 유사하지만, 문서를 복제하지는 않음
            - POST : 데이터를 서버로 송신. 서버는 이를 특정 아이템에 덧붙임 (생성)
            - PUT : 데이터를 서버로 송신. 서버가 특정 아이템을 완전히 대체함 (수정)
        - HTTP 응답 헤더
            - status_code : 상태를 나타내는 숫자 값
            - status_string : 사람이 식별 가능한 상태 문자 값
            - server_identifiction : 서버정보 설명
            - datasize : 데이터의 크기 (바이트 단위)
            - document_type : 문서 유형 (text/html, image/jpeg 등)
    + HTTP 1.1과 2.0의 차이
        - 처리 방식
            + HTTP 1은 여러 요청을 받아야만 다음 요청이 처리될 수 있음
            + HTTP 2는 여러 리소스를 한번에 받아올 수 있음 (Multiplexed Streams)
        - 데이터
            + HTTP 1은 문자열로 전송
            + HTTP 2는 이진법으로 인코딩하여 압축 전송함
        그 외에도 HTML문서 상에 필요한 리소스를 클라이언트 요청 없이 보내줄 수 있는 Server Push 기능이나, 첫 번째 패킷 때문에 지연되는 HOL Blocking 현상이 발생하지 않는 것으로 전체적인 속도가 향상되었다.
        - TCP의 3way handshake 과정을 최적화하기 위해 UDP를 사용하는 [HTTP 3.0](https://evan-moon.github.io/2019/10/08/what-is-http3/) 또한 존재한다.