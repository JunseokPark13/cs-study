6. 비동기 프로그래밍(Asyncronous Programming)
    + 어떤 일이 완료되기를 기다리지 않고 다음 코드를 실행하는 방식을 비동기 프로그래밍이라고 한다.
    + 브라우저에서의 비동기 프로그래밍은 주로 통신과 같이 오래 걸리는 작업들을 브라우저에 위임할 때 이루어진다.
    + Ajax 란 Asynchronous Javascript and XML 의 약자로, 동적인 웹 페이지를 만들기 위한 개발 기법이다.
        - 웹 페이지 전체를 다시 로딩하지 않고도 백그라운드 영역에서 서버와 통신하고, 그 결과를 웹 페이지의 일부분만을 갱신할 수 있다.
        - 과거에는 XML을 사용하였으나, 최근에는 JSON을 사용한다.
        - Ajax 장점
            - 서버의 처리가 완료될 때 까지 기다리지 않고 처리 가능
            - 웹 페이지의 속도 향상
        - Ajax 단점
            - 히스토리 관리가 되지 않는다.
            - 연속 데이터 요청 시 서버 부하가 생길 수 있다.
        - XMLHttpRequest 객체를 사용하여 웹 서버와 통신하는 것이 일반적이었으나, 최근에는 fetch API를 사용하는 것이 일반적이다.
    + Promise & Callback
        - 자바스크립트에서 비동기처리를 위해 사용되는 패턴으로, callback 함수를 통해 비동기 로직이 끝났을 때 이를 실행시키는 방식으로 비동기 작업 완료 시의 행동 수행이 가능하다.
        - Promise 는 Promise 생성자 함수를 통해 비동기 처리에 대한 코드를 작성하고, 성공 시에는 resolve, 실패 시에는 reject를 호출하는 방식으로 비동기 처리 결과를 후속 처리 메소드로 전달할 수 있다.
        - 후속 처리 메소드로는 then, catch 등이 있고, then 을 통한 메소드 체이닝을 통해 콜백지옥 문제를 해결할 수 있다.
        - callback 에서 비동기 로직의 결과값을 처리하기 위해서는 callback 내에서만 처리해주어야 하기 때문에 밖에서는 비동기 처리를 통해 전해진 값을 알 수 없다.
        - 하지만 Promise를 사용한다면 비동기 처리를 통한 값이 Promise 객체에 저장되기 때문에 코드 작성이 용이해진다.
    + Async, Await, Promise
        - Async, Await 은 Promise 를 더 쉽게 사용할 수 있도록 ES8 에서 도입된 문법이다.
        - 어떠한 함수 앞에 async 라는 키워드를 붙이면, 그 함수는 비동기 함수가 되고 항상 Promise 객체를 반환하게 된다. 
        - 비동기 함수 내에서는 await 키워드를 쓸 수 있는데, 이는 뒤에 오는 Promise가 결과값을 가질 때 까지 비동기 함수의 실행을 중단시킨다.

7. 자바스크립트 타입
    + boolean, string, number, null, undefined, symbol
    + Symbol : ES6에 새롭게 추가되어, 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키를 만들기 위해 사용함
        - `Symbol()` 함수로 생성이 가능하며, 이미 생성된 symbol은 객체가 아닌 변경 불가능한 원시 타입의 값이다. (new 연산자를 사용하지 않음)
8. 실행 컨텍스트
    + 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이다. 이는 실행 가능한 코드가 실행되기 위해 필요한 환경이라고 할 수 있다.
    + Scope, Hoisting, this, Closure 등의 동작 원리를 담고있는 자바스크립트의 핵심 원리이다.
    + 코드를 실행하면, 실행 컨텍스트 스택이 생성된다. 현재 실행 중인 컨텍스트에서 이 컨텍스트와 관련 없는 코드(다른 함수 등)가 실행되면 새로운 컨텍스트가 생성되고, 이는 스택에 쌓인다.
        1. 전역 코드로 컨트롤이 진입하면, 전역 EC(실행 컨텍스트)가 생성되고 스택이 쌓인다. 이는 애플리케이션 종료 시 까지 유지된다.
        2. 함수 호출 시 해당 함수의 EC가 생성되고 직전에 실행된 코드 블록의 EC 위에 쌓인다.
        3. 함수 실행이 끝나면 해당 함수의 EC를 파기하고, 직전 EC에 컨트롤을 반환한다.
    + 실행 컨텍스트는 3가지 프로퍼티를 소유하고 있다.
        - Variable Object (VO / 변수 객체)
            + 실행에 필요한 여러 정보들을 담는 객체로, 변수, 매개변수와 인수, 함수 선언에 대한 정보를 담고있다.
            + 전역 컨텍스트의 경우, 유일하고 최상위에 위치하는 전역 객체(Global Object / GO) 를 가리킨다.     
            ![image](https://user-images.githubusercontent.com/49611158/146363201-dc636fb3-70c7-4605-8605-7013aa5bc403.png)
            + 함수 컨텍스트의 경우, 활성 객체(Activation Object / AO) 를 가리키고, 전역 객체와 달리 매개변수와 인수의 정보를 담고있는 객체인 Argument Object가 추가된다.    
            ![image](https://user-images.githubusercontent.com/49611158/146363227-cca4afdd-9e1d-473e-bc69-1c7a62650df9.png)
        - Scope Chain (SC)
            + 일종의 리스트로, 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고 있다. 
            + 해당 전역 또는 함수가 참조할 수 있는 GO 나 AO 의 리스트를 가리킨다.
            + 현재 EC의 활성 객체를 선두로 하여 순차적으로 상위 컨텍스트의 활성 객체를 가리키고, 마지막에는 전역 객체를 가리킨다.
            + 엔진은 이 스코프 체인을 통해 렉시컬 스코프를 파악한다.
        - this value
            + this 프로퍼티에는 this 값이 할당된다.
            + this에 할당되는 값은 함수 호출 패턴에 의해 결정된다. 

9. 호이스팅 (Hoisting)
    + var 로 선언한 표현식이나 function 선언문 등을 실행 단계에서 해당 Scope의 맨 위로 끌어올리는 것을 의미한다.
    + var 나 함수의 선언만 끌어올려지고, 할당은 끌어올려지지 않는다.
    + let, const 변수 선언과 함수 표현식은 호이스팅이 발생하지 않는다.
        - 함수선언식은 호이스팅이 동작한다
    + 코드의 가독성이나 유지보수를 위해 호이스팅이 일어나지 않게 하는 것이 좋다
10. 스코프 (Scope)
    + 스코프란 변수에 접근할 수 있는 범위를 뜻한다.
    + 전역 스코프
        - 전역에 선언되어 있어 어느 곳에서든지 해당 변수에 접근할 수 있다.
    + 지역 스코프
        - 해당 지역에서만 접근할 수 있고, 벗어나면 접근할 수 없다.
    + 자바스크립트는 함수 레벨 스코프를 사용한다.
        - 함수의 코드 블록만을 스코프로 인정한다. 전역 함수 외부에서 생성한 변수는 모두 전역벼수이다.
        - for 문 내에서 선언한 변수를 코드블록 외부에서도 참조 가능하다.
    + 렉시컬 스코프
        - 함수를 어디서 호추하는지가 아니라, 어디에 선언하였는지에 따라 스코프가 결정되는 것을 의미한다. 
11. 클로저 (Closure)
    + 내부 함수가 외부 함수의 내부 변수에 접근하는 것을 의미한다.
    + 자바스크립트 함수가 선언될 때, 렉시컬 스코프의 정보를 스코프 체인을 통해 유효 범위를 인지한다.
    + 특정 함수 내부에 있는 내부 함수에서 외부 함수의 변수를 참조하고 있을 때, 외부 함수의 실행이 종료되어도 내부 함수는 렉시컬 스코프를 통해 외부 함수의 변수들을 참조할 수 있다. 
12. this
    + 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수라고 할 수 있다.
    + this 는 함수가 호출되는 방식에 따라 동적으로 변경된다.
    + this 의 동작 방식
        - 기본 바인딩 (전역 객체) : window 를 컨텍스트 객체로 가질 때
        - 암시적 바인딩 : 어떤 객체를 통해 함수가 호출된다면, 그 객체가 this 의 컨텍스트가 된다.
        - 명시적 바인딩 : call, apply, bind 메소드로 컨텍스트를 직접 지정해주는 방식
        - new 바인딩 : 생성자 함수로 호출 시 생성자 함수가 생성할 객체에 바인딩 하는 방식
    + Call, Apply, Bind
        - this 를 바인딩하기 위한 메서드이다.
        - Call, Apply 는 첫 번째 인자로 바인딩할 객체를 넘기고, 두 번째 이후로는 인자를 넘긴다.
            - Call 은 두 번째 이후로 인자를 하나씩 넘김 `foo.call(obj, a, b, c)`
            - Apply 는 두 번째 이후로 인자를 배열로 넘김 `foo.apply(obj, [a, b, c])`
            - Bind 는 call, apply 와 유사하지만 함수를 실행시키지 않고 객체만 지정해주고, 지정된 함수를 리턴한다는 차이가 있다.
