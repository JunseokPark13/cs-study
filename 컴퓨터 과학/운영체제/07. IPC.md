# IPC

## IPC (Inter-Process Communication)란
+ 스레드는 프로세스 안에서 자원을 공유하므로 서로 영향을 받지만, 프로세스는 독립적이므로 서로 영향을 끼치지 않는다.
+ 독립적인 구조이지만, 프로세스 간의 통신이 필요한 순간이 있다. 이 때 필요한 것이 IPC 이다.
+ 상호협조적인 cooperating process 들은 커널이 제공하는 IPC 설비들을 이용하여 프로세스간 통신을 할 수 있고, 이를 통해 정보 공유나 속도 향상, 모듈화 등의 목적을 이룰 수 있다.

<br>


## IPC 모델 - 공유 메모리 (Shared Memory)

<br>

![image](https://user-images.githubusercontent.com/49611158/147211629-abc610f8-a150-4ec3-9e04-21f4d22c4488.png)

<br>

+ 두 개 이상의 프로세스들이 주소 공간의 일부를 공유하며, 공유한 메모리 영역에 읽기/쓰기를 통해 통신을 수행한다.
+ 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주게 되고, 이후 어떤 프로세스건 해당 메모리 영역에 접근할 수 있다.
+ 공유 메모리가 설정되면, 그 이후의 통신은 커널이 관여하지 않아도 가능하다.
+ 장점
    - 커널의 관여 없이 메모리를 직접 사용하여 IPC 속도가 빠르다.
    - 프로그램 레벨에서 통신 기능을 제공하여, 자유로운 통신이 가능하다.
+ 단점
    - 메시지 전달 방식이 아니므로 데이터를 읽어야 하는 시점을 알 수 없다.
        + 프로세스 A 가 공유 메모리에 데이터를 전달해도, 프로세스 B는 이를 알 수 없다.
        + 때문에 별도의 동기화 기술이 필요하다.
    - 동시에 같은 메모리 위치를 접근하는 상황이 발생할 수 있다.
        + 공유 메모리에 접근할 프로세스 간의 Lock 메커니즘이 필요하다.

<br>

##  IPC 모델 - 메시지 전달 (Message Passing)

<br>

![image](https://user-images.githubusercontent.com/49611158/147216268-a8c10069-79be-4cd2-8394-271dbc89b2a6.png)

<br>

+ 커널 메모리 영역에 메시지 전달을 위한 채널을 만들어 협력하는 프로세스들 사이에 메시지 형태로 정보를 보내고 받는 방식이다.
+ 커널을 경유하여 메시지를 송/수신자끼리 주고 받으며, 커널에서는 데이터를 버퍼링한다.
+ 프로세스 간의 메모리 공유 없이 동작이 가능하다.
+ 장점
    - 커널에서 데이터를 주고 받는 것을 컨트롤 할 수 있으므로 동기화 로직이 필요하지 않다.
+ 단점
    - 커널을 통해서 데이터를 주고 받기 때문에 Shared Memory 모델보다 느리다.

### 메시지 전달 모델의 종류
+ Direct Communication
    - 통신하려는 프로세스의 이름을 명시적으로 표시하여 메시지를 직접 전달하는 방식
    - 프로세스 간 링크는 유일하고, 대부분 양방향으로 구성한다.

+ Indirect Communication
    - Mailbox 혹은 Port 를 통해 메시지를 간접 전달하는 방식이다.
    - 중간 매게체로만 전송을 하면 되기 때문에 복잡한 Communication Link를 만들 수 있고, 다대다 관계가 가능하다.

### 메시지 전달 모델의 예시

<br>

![image](https://user-images.githubusercontent.com/49611158/147217782-6f753327-1e6e-4ed4-847d-f4879103e1b7.png)

<br>

+ 파이프 (Pipe)
    - 두 개의 프로세스를 파이프로 연결하여 하나의 프로세스는 데이터를 쓰기만 하고 다른 프로세스는 데이터를 읽기만 하며 데이터 통신을 수행한다.
    - 1:1 통신이면서 한 쪽 방향으로만 데이터가 이동한다.
    - 주로 부모-자식 간의 단방향 통신으로 사용된다.
    - 용량 제한이 있으므로 파이프가 가득 차면 사용할 수 없다.
    - 한 쪽 프로세스는 읽기만, 다른 프로세스는 쓰기만 하는 단순한 데이터 흐름에 적합하다.
    - 익명 Pipe
        + 연결된 두 개의 프로세스 중 하나는 데이터를 쓰기만 하고, 하나는 읽기만 한다.
        + 한 쪽 방향으로만 통신이 가능한 반이중 통신이라고도 부른다.
        + 양쪽 송수신을 위해서는 2개의 파이프를 만들어야 한다.
    - Named Pipe
        + 전혀 모르는 상태의 프로세스들 사이의 통신에 사용한다.
        + 부모 프로세스와 무관한 다른 프로세스도 통신이 가능하다.
        + 하지만 읽기/쓰기는 동시에 할 수 없으므로 전이중 통신을 위해서는 2개의 파이프를 만들어야 한다.

<br>

![image](https://user-images.githubusercontent.com/49611158/147217833-f8a30e13-c3e4-4429-afae-f10542c470c5.png)

<br>


+ 메시지 큐 (Message Queue)
    - FIFO 자료 구조를 가지는 큐를 이용하여 데이터를 전송 및 수신하는 방식
    - 파이프가 스트림 기반이라면, 메시지 큐는 메시지(또는 패킷) 단위로 동작한다.
    - 부모/자식 관계가 아니더라도, 어느 프로세스 간의 데이터 송수신이 가능하다는 장점이 있다.
    - 양방향 통신이 가능하고, 메시지의 형태는 사용자가 정의하여 사용가능하다.
    - Message Queue에 쓸 데이터에 번호를 붙임으로써 다수의 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.
    - 비동기 방식이기에 방대한 처리량이 있다면 큐에 넣은 후 나중에 처리할 수 있다.
    - 데이터가 많이 쌓일 수록 추가적인 메모리 자원이 필요하고, 큐에 데이터를 넣고 나오는 과정에서 오버헤드가 발생할 수 있다.

<br>

![image](https://user-images.githubusercontent.com/49611158/147221640-5fd81b26-1c6b-459b-aaad-5a37c50a7d70.png)

<br>

+ 소켓 (Socket)
    - 양쪽 PC에서 각각 임의의 포트를 정하고, 해당 포트 간의 대화를 통해 데이터를 주고 받는 방식이다.
    - 소켓이 네트워크 기능을 담고 있으므로 이를 IPC로도 사용이 가능하다. 
    - 네트워크 소켓으로 Client-Server 구조로 원격에서 프로세스 간 데이터를 공유할 때 사용한다.
    - 프로세스는 포트 번호를 이용하여 통신하려는 상대 프로세스의 소켓을 찾아간다.