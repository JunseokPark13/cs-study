# CPU 스케쥴링

## CPU 스케줄링의 목적
+ CPU 스케줄러는 다중 프로그램 운영체제의 기본으로, 운영체제는 CPU 를 여러 프로세스에 교환하며 배정하는 방식으로 컴퓨터를 보다 생산적으로 만든다.
+ 운영체제는 실행 대기 중인 프로세스들에게 자원 배정을 적절하게 하여 시스템 성능을 끌어올릴 수 있다.
+ 어떤 프로세스가 대기해야 할 경우, 운영체제는 CPU를 그 프로세스로부터 회수해 다른 프로세스에 할당한다.
+ 스케쥴링은 정책에 따라 다음과 같이 나뉠 수 있다.
    - CPU 이용률을 최대화
    - 오버헤드를 최소화
    - 모든 프로세스가 공평하게 분배되도록


<br>

## 선점/비선점 스케쥴링

### 스케쥴링이 일어나는 시점

<br>

![image](https://user-images.githubusercontent.com/49611158/147337614-4f0df9d3-8736-4831-bae9-1c995356c5f1.png)

<br>

CPU 스케쥴링의 결정은 다음의 네 가지 상황에서 발생할 수 있다.
1. Running -> Waiting : 한 프로세스가 실행 상태에서 대기 상태로 전환될 때 (I/O 발생)
2. Running -> Ready : 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 (인터럽트 발생)
3. Waiting -> Ready : 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 (I/O 종료)
4. Running -> Terminate : 프로세스가 종료될 때

### 선점 스케쥴링 (Preemptive Scheduling)
+ 운영체제가 CPU 사용권을 선점하고, 특정 요건에 따라 각 프로세스의 요청이 있을 때 프로세스들에게 분배한다.
+ 가장 자원이 필요한 프로세스에게 CPU를 분배하고, 상황에 따라 회수할 수도 있다.
+ 빠른 응답시간을 요구하는 대화식 시분할 시스템에 적합하다.
+ 시분할 시스템에서 타임 슬라이스가 소진되었거나, 더 높은 우선 순위 프로세스가 발생 되었음을 알았을 때 발생할 수 있다. (2, 3번)

### 비선점 스케쥴링 (Non-Preemptive Scheduling)
+ 어떤 프로세스가 CPU를 할당받으면 그 프로세스가 종료되거나, 입출력 요구가 발생하여 자발적으로 중지될 때 까지 계속 실행되도록 보장한다.
+ 순서대로 처리되므로 공정성이 있고, 다음에 처리해야할 프로세스와 상관없이 응답 시간 예상이 가능하다.
+ 스케쥴러 호출 빈도가 낮고, 문맥교환에 의한 오버헤드가 적다.
+ 일괄처리 시스템에 적합하지만, CPU 사용시간이 긴 프로세스가 다른 프로세스를 대기시킬 수도 있으므로 처리율이 떨어질 수 있다.
+ 위 상황에서 1, 4번에 해당하는 경우 발생한다. 

<br>

## CPU Burst, I/O Burst Cycle

<br>

![image](https://user-images.githubusercontent.com/49611158/147338881-d5fa1f9d-41a7-41de-9ce7-d3c91fae07a6.png)

<br>

+ 프로세스의 실행은 CPU 실행과 입/출력 대기의 사이클로 구성된다. 프로세스는 이 둘의 상태를 오가며 수행된다.
+ CPU Burst : 프로세스의 사용 중에 연속적으로 CPU를 사용하는 단절된 구간. 스케쥴링의 단위이다.
+ I/O Burst : 프로세스의 실행 중에 I/O작업이 끝날 때 까지 Block 되는 구간이다.


<br>

## 스케쥴링 알고리즘 평가 기준
+ CPU 이용률 : 전체 시스템 시간 중, CPU가 작업을 처리하는 시간의 비율
+ 처리량 : CPU가 단위 시간 당 처리하는 프로세스의 개수
+ 총 처리 시간 : 프로세스가 시작해서 끝날 때 까지 걸린 시간
+ 대기 시간 : 프로세스가 준비완료 큐에서 대기하는 시간의 총 합
+ 응답 시간 : 대화식 시스템에서 요청 후 첫 응답이 오기까지 걸린 시간


<br>

## 스케쥴링의 종류 

### FCFS (First Come, First Serve)
+ 먼저 도착한 프로세스를 먼저 처리하는 스케쥴링 알고리즘이다.
+ 비 선점형 스케쥴링이다.
+ FIFO 큐를 이용하여 간단하게 구현할 수 있다.
+ Convoy Effect : 긴 처리시간의 프로세스가 먼저 선점되어버리면, 나머지 프로세스들은 끝날 때 까지 대기해야한다.     
때문에 먼저 도착한 프로세스의 버스트 타임에 따라 평균 대기시간의 편차가 크다.

### SJF (Shorted Job First)
+ 최단작업우선 스케쥴링 알고리즘이다. 가장 CPU 버스트 타임이 짧은 프로세스를 우선시한다. 때문에 가장 적은 평균 대기 시간을 달성할 수 있다. 
+ 선점형과 비선점형 두 종류가 있다.
    - 비선점형일 경우, 프로세스 실행 도중 새로운 프로레스가 준비 큐에 도착하면 선택이 발생한다.
+ CPU 버스트 타임이 동일하다면 FCFS 방식을 따른다.


### Priority Scheduling (우선순위 스케쥴링)
+ 미리 주어진 프로세스의 우선순위에 따라서 스케쥴링하는 방식이다.
+ 선점형과 비선점형이 있다.
+ SJF도 우선순위 스케쥴링의 일종이라고 볼 수 있다. (최소 버스트 시간 기준)
+ Starvation (기아 현상) : 우선순위가 낮은 프로세스는 할당이 계속 미뤄질 가능성이 있다.
    - Aging : 기다리는 시간에 따라 우선순위를 증가시켜주는 방식을 적용할 수 있다.
+ 우선순위가 같다면 FCFS 방식을 따른다. 


### Round Robin (라운드 로빈)
+ 정해진 시간 할당량(Time Quantum, 혹은 타임 슬라이스 - Time Slice)만큼 프로세스를 할당한 뒤, 작업이 끝난 프로세스는 준비완료 큐의 가장 마지막에 가서 재할당을 기다린다.
+ 선점형 스케쥴링이다.  
+ 때문에 시간 할당량을 적당하게 조절하지 않으면 전혀 이득을 보지 못할 수 있다.
    - 너무 짧으면 Context Switching 이 빈번하게 발생한다.
    - 너무 길면 FCFS 와 다를 바가 없어진다.

### Multilevel-Queue (다단계 큐)
+ 준비완료 큐를 여러 개의 큐로 분류하여 각 큐가 각각 다른 스케쥴링 알고리즘을 가지는 방식이다.
+ 메모리 크기, 우선순위, 유형 등 프로세스의 특성에 따라 하나의 큐에 영구적으로 할당한다.
    - 때문에 큐와 큐 사이에도 스케쥴링이 필요하다.
+ 각 큐에 자체 스케쥴링 알고리즘을 구현할 수 있다.

### Multilevel-Feedback-Queue (다단계 피드백 큐)
+ 기존의 다단계 큐 방식은 특정 프로세스가 큐에 고정되는 방식이었다면, 다단계 피드백 큐에서는 큐와 큐 사이에 프로세스가 이동하는 것을 허용한다.
+ 큐를 구분하는 기준은 CPU Burst time이며, 입출력 중심의 프로세스와 대화형 중심의 프로세스를 높은 우선순위의 큐에 넣는다.
+ 기아상태 예방을 위한 노화(Aging) 정책도 진행된다.